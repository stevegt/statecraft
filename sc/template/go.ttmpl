package {{.Package}}

import "fmt"

// AUTOMATICALLY GENERATED by {{ .Cmdline }}
// DO NOT EDIT
// Original .statecraft file contents included at bottom.

type handlers interface {
    {{- range $n := .MethodNames}}
    {{ $n }}()
    {{- end }}
}

// states
type State struct {
    name string
    label string
}

func (s State) String() string {
    return s.name    
}

func (s State) Label() string {
    return s.label    
}

var (
    {{- range $s := .LsStates }}
    {{ $s.Name }} = State{"{{ $s.Name }}", "{{$s.Label}}"}
    {{- end}}
)

// events
type Event struct {
    name string
}

func (e Event) String() string {
    return e.name    
}

var (
    {{range $e := .EventNames}}
    {{$e}} = Event{"{{$e}}"}
    {{- end}}
)

type transition struct {
    Src    State
    Event  Event
	Method func()
	Dst    State
}

type transitions map[Event]transition

type graph map[State]transitions

type Machine struct {
    g graph
    State State
}

func New(h handlers, initState State) (m *Machine) {
    m = &Machine{
        State: initState,
    }
    m.g = graph{
        {{- range $s := .LsStates }}
        {{ $s.Name }}:  transitions{
            {{- range $e, $t := $s.Transitions }}
            {{- if $t.Method }}
            {{ $e }}: transition{
                    Dst: {{ $t.Dst }}, 
                    Method: h.{{ $t.Method }}, 
            },
            {{- else }}
            {{ $e }}: transition{
                    Dst: {{ $t.Dst }},
            },
            {{- end}}
            {{- end}}
        },
        {{- end}}
    }
    return
}

func (m *Machine) Tick(event Event) (newState State, err error) {
    src := m.g[m.State]
    t, ok := src[event]
    if !ok {
        err = fmt.Errorf("unhandled: state %s event %s", m.State.String(), event.String())
        return
    }
    m.State = t.Dst
    if t.Method != nil {
        t.Method()
    }
    return m.State, nil
}

var txt string = `
{{ .Txt }}
` 
