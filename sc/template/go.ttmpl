package {{.Package}}

import "fmt"

// AUTOMATICALLY GENERATED by {{ .Cmdline }}
// DO NOT EDIT
// Original .statecraft file contents included at bottom.

type Handlers interface {
    {{- range $n := .MethodNames}}
    {{ $n }}()
    {{- end }}
}

// states
type State string
const (
    {{- range $s := .LsStates }}
    {{ $s.Name }} State = "{{ $s.Name }}" // {{$s.Label}}
    {{- end}}
)

// events
type Event string
const (
    {{range $e := .EventNames}}
    {{$e}} Event = "{{$e}}"
    {{- end}}
)

type Transition struct {
    Src    State
    Event  Event
	Method func()
	Dst    State
}

type Transitions map[Event]Transition

type Graph map[State]Transitions

type Machine struct {
    g Graph
    State State
}

func New(handlers Handlers, initState State) (m *Machine) {
    m = &Machine{
        State: initState,
    }
    m.g = Graph{
        {{- range $s := .LsStates }}
        State("{{ $s.Name }}"):  Transitions{
            {{- range $e, $t := $s.Transitions }}
            {{- if $t.Method }}
            Event("{{ $e }}"): Transition{
                    Dst: State("{{ $t.Dst }}"), 
                    Method: handlers.{{ $t.Method }}, 
            },
            {{- else }}
            Event("{{ $e }}"): Transition{
                    Dst: State("{{ $t.Dst }}"),
            },
            {{- end}}
            {{- end}}
        },
        {{- end}}
    }
    return
}

func (m *Machine) Tick(event Event) (newState State, err error) {
    src := m.g[m.State]
    t, ok := src[event]
    if !ok {
        err = fmt.Errorf("unhandled: state %s event %s", string(m.State), string(event))
        return
    }
    m.State = t.Dst
    if t.Method != nil {
        t.Method()
    }
    return m.State, nil
}

var txt string = `
{{ .Txt }}
` 
